import { Router, Response } from 'express';
import { query } from '../db/database';
import { authenticate, requireAdmin, AuthRequest } from '../middleware/auth';
import { generateQRToken } from '../utils/jwt';
import { v4 as uuidv4 } from 'uuid';
import { logVoucherAction } from '../utils/auditLog';
import { sanitizeHtml } from '../utils/sanitize';

const router = Router();

// Get all active vouchers (public for customers)
router.get('/', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const userType = req.user?.type || 'customer';

    const result = await query(
      `SELECT * FROM vouchers
       WHERE is_active = true
       AND (expiry_date IS NULL OR expiry_date > NOW())
       AND ($1 = ANY(target_user_types) OR target_user_types IS NULL)
       ORDER BY is_featured DESC, points_required ASC`,
      [userType]
    );

    res.json({ vouchers: result.rows });
  } catch (error) {
    console.error('Get vouchers error:', error);
    res.status(500).json({ error: 'Failed to fetch vouchers' });
  }
});

// Get all vouchers including inactive with usage statistics (staff & admin)
router.get('/all', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const result = await query(`
      SELECT
        v.*,
        COUNT(vi.id) FILTER (WHERE vi.status = 'used') as times_redeemed,
        COUNT(vi.id) FILTER (WHERE vi.status = 'active') as active_redemptions,
        COUNT(DISTINCT vi.user_id) as unique_users,
        MAX(vi.used_at) as last_redeemed_at
      FROM vouchers v
      LEFT JOIN voucher_instances vi ON v.id = vi.voucher_id
      GROUP BY v.id
      ORDER BY v.created_at DESC
    `);
    res.json(result.rows);
  } catch (error) {
    console.error('Get all vouchers error:', error);
    res.status(500).json({ error: 'Failed to fetch vouchers' });
  }
});

// Get single voucher
router.get('/:id', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params;
    const result = await query('SELECT * FROM vouchers WHERE id = $1', [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Voucher not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Get voucher error:', error);
    res.status(500).json({ error: 'Failed to fetch voucher' });
  }
});

// Create voucher (admin only)
router.post('/', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const {
      title,
      description,
      category,
      points_required,
      voucher_type,
      benefit_type,
      benefit_value,
      cash_value,
      is_active,
      is_featured,
      expiry_type,
      expiry_date,
      expiry_days,
      target_user_types,
      max_redemptions_per_user,
      max_redemptions_total,
      valid_from,
      valid_until,
      image_url,
      redemption_window,
      requires_minimum_purchase,
      valid_days_of_week,
      valid_outlets,
      auto_expire_hours
    } = req.body;

    // Sanitize title to prevent XSS
    const sanitizedTitle = sanitizeHtml(title) || '';

    // Business rule validations
    if (!sanitizedTitle || points_required === undefined || !voucher_type) {
      return res.status(400).json({ error: 'Title, points_required, and voucher_type are required' });
    }

    // Validate title length
    if (sanitizedTitle.trim().length < 3) {
      return res.status(400).json({ error: 'Title must be at least 3 characters' });
    }
    if (sanitizedTitle.length > 200) {
      return res.status(400).json({ error: 'Title must be less than 200 characters' });
    }

    // Check if HTML/XSS was detected and removed
    if (title !== sanitizedTitle) {
      return res.status(400).json({ error: 'Title contains invalid characters or HTML tags' });
    }

    // Check for duplicate titles (case-insensitive)
    const duplicateCheck = await query(
      'SELECT id FROM vouchers WHERE LOWER(title) = LOWER($1)',
      [title]
    );
    if (duplicateCheck.rows.length > 0) {
      return res.status(400).json({ error: 'A voucher with this title already exists' });
    }

    // Validate points_required
    if (points_required < 0) {
      return res.status(400).json({ error: 'Points required must be non-negative' });
    }
    if (points_required > 1000000) {
      return res.status(400).json({ error: 'Points required must be less than 1,000,000' });
    }

    // Validate voucher_type
    if (!['free_item', 'discount_amount', 'percentage_discount', 'merch'].includes(voucher_type)) {
      return res.status(400).json({ error: 'Invalid voucher_type' });
    }

    // Validate discount_percentage (0-100%)
    if (req.body.discount_percentage !== undefined && req.body.discount_percentage !== null) {
      const discountPercentage = req.body.discount_percentage;
      if (discountPercentage < 0 || discountPercentage > 100) {
        return res.status(400).json({ error: 'Discount percentage must be between 0 and 100' });
      }
    }

    // Validate benefit_value (must be non-negative)
    if (benefit_value !== undefined && benefit_value !== null && benefit_value < 0) {
      return res.status(400).json({ error: 'Benefit value must be non-negative' });
    }

    // Accept both field names for backward compatibility
    const totalRedemptionLimit = req.body.total_redemption_limit || max_redemptions_total;

    // Validate redemption limits
    if (max_redemptions_per_user !== undefined && max_redemptions_per_user !== null && max_redemptions_per_user < 0) {
      return res.status(400).json({ error: 'Max redemptions per user must be non-negative' });
    }
    if (totalRedemptionLimit !== undefined && totalRedemptionLimit !== null && totalRedemptionLimit < 0) {
      return res.status(400).json({ error: 'Max total redemptions must be non-negative' });
    }

    // Validate date logic
    if (valid_from && valid_until) {
      const fromDate = new Date(valid_from);
      const untilDate = new Date(valid_until);
      if (fromDate >= untilDate) {
        return res.status(400).json({ error: 'Valid from date must be before valid until date' });
      }
    }

    // Validate expiry_date is in future
    if (expiry_type === 'fixed_date' && expiry_date) {
      const expiryDate = new Date(expiry_date);
      if (expiryDate < new Date()) {
        return res.status(400).json({ error: 'Expiry date must be in the future' });
      }
    }

    // Validate redemption_window
    if (redemption_window && !['unlimited', 'once_per_day', 'once_per_week', 'once_per_month', 'once_per_shift'].includes(redemption_window)) {
      return res.status(400).json({ error: 'Invalid redemption_window' });
    }

    // Validate minimum purchase
    if (requires_minimum_purchase && requires_minimum_purchase < 0) {
      return res.status(400).json({ error: 'Minimum purchase amount must be non-negative' });
    }

    // Validate auto_expire_hours
    if (auto_expire_hours && auto_expire_hours <= 0) {
      return res.status(400).json({ error: 'Auto expire hours must be greater than 0' });
    }

    const result = await query(
      `INSERT INTO vouchers (
        title, description, category, points_required, voucher_type,
        benefit_type, benefit_value, cash_value, is_active, is_featured,
        expiry_type, expiry_date, expiry_days, target_user_types,
        max_redemptions_per_user, max_redemptions_total,
        valid_from, valid_until, image_url,
        redemption_window, requires_minimum_purchase, valid_days_of_week,
        valid_outlets, auto_expire_hours
      )
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24)
       RETURNING *`,
      [
        title,
        description,
        category || null,
        points_required,
        voucher_type,
        benefit_type || 'free_item',
        benefit_value || null,
        cash_value || null,
        is_active ?? true,
        is_featured ?? false,
        expiry_type || 'no_expiry',
        expiry_date || null,
        expiry_days || null,
        target_user_types || ['customer', 'employee', 'staff'],
        max_redemptions_per_user || null,
        max_redemptions_total || null,
        valid_from || null,
        valid_until || null,
        image_url || null,
        redemption_window || 'unlimited',
        requires_minimum_purchase || null,
        valid_days_of_week || null,
        valid_outlets || null,
        auto_expire_hours || null
      ]
    );

    const newVoucher = result.rows[0];

    // Audit log
    await logVoucherAction(req, 'create', newVoucher.id, newVoucher.title, {
      after: newVoucher
    });

    res.status(201).json(newVoucher);
  } catch (error) {
    console.error('Create voucher error:', error);
    res.status(500).json({ error: 'Failed to create voucher' });
  }
});

// Update voucher (admin only)
router.patch('/:id', authenticate, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params;

    // Get current voucher for audit trail
    const oldVoucherResult = await query('SELECT * FROM vouchers WHERE id = $1', [id]);
    if (oldVoucherResult.rows.length === 0) {
      return res.status(404).json({ error: 'Voucher not found' });
    }
    const oldVoucher = oldVoucherResult.rows[0];

    const {
      title,
      description,
      category,
      points_required,
      voucher_type,
      benefit_type,
      benefit_value,
      cash_value,
      is_active,
      is_featured,
      expiry_type,
      expiry_date,
      expiry_days,
      target_user_types,
      max_redemptions_per_user,
      max_redemptions_total,
      valid_from,
      valid_until,
      image_url,
      redemption_window,
      requires_minimum_purchase,
      valid_days_of_week,
      valid_outlets,
      auto_expire_hours
    } = req.body;

    // Validate title if provided
    if (title !== undefined) {
      if (title.trim().length < 3) {
        return res.status(400).json({ error: 'Title must be at least 3 characters' });
      }
      if (title.length > 200) {
        return res.status(400).json({ error: 'Title must be less than 200 characters' });
      }

      // Check for duplicate titles (excluding current voucher)
      const duplicateCheck = await query(
        'SELECT id FROM vouchers WHERE LOWER(title) = LOWER($1) AND id != $2',
        [title, id]
      );
      if (duplicateCheck.rows.length > 0) {
        return res.status(400).json({ error: 'A voucher with this title already exists' });
      }
    }

    // Validate points_required if provided
    if (points_required !== undefined && points_required < 0) {
      return res.status(400).json({ error: 'Points required must be non-negative' });
    }

    // Validate redemption limits
    if (max_redemptions_per_user !== undefined && max_redemptions_per_user !== null && max_redemptions_per_user <= 0) {
      return res.status(400).json({ error: 'Max redemptions per user must be greater than 0' });
    }
    if (max_redemptions_total !== undefined && max_redemptions_total !== null && max_redemptions_total <= 0) {
      return res.status(400).json({ error: 'Max total redemptions must be greater than 0' });
    }

    // Validate date logic
    if (valid_from !== undefined && valid_until !== undefined && valid_from && valid_until) {
      const fromDate = new Date(valid_from);
      const untilDate = new Date(valid_until);
      if (fromDate >= untilDate) {
        return res.status(400).json({ error: 'Valid from date must be before valid until date' });
      }
    }

    const updates: string[] = [];
    const values: any[] = [];
    let paramCount = 1;

    if (title !== undefined) {
      updates.push(`title = $${paramCount++}`);
      values.push(title);
    }
    if (description !== undefined) {
      updates.push(`description = $${paramCount++}`);
      values.push(description);
    }
    if (category !== undefined) {
      updates.push(`category = $${paramCount++}`);
      values.push(category);
    }
    if (points_required !== undefined) {
      updates.push(`points_required = $${paramCount++}`);
      values.push(points_required);
    }
    if (voucher_type !== undefined) {
      if (!['free_item', 'discount_amount', 'percentage_discount', 'merch'].includes(voucher_type)) {
        return res.status(400).json({ error: 'Invalid voucher_type' });
      }
      updates.push(`voucher_type = $${paramCount++}`);
      values.push(voucher_type);
    }
    if (benefit_type !== undefined) {
      updates.push(`benefit_type = $${paramCount++}`);
      values.push(benefit_type);
    }
    if (benefit_value !== undefined) {
      updates.push(`benefit_value = $${paramCount++}`);
      values.push(benefit_value);
    }
    if (cash_value !== undefined) {
      updates.push(`cash_value = $${paramCount++}`);
      values.push(cash_value);
    }
    if (is_active !== undefined) {
      updates.push(`is_active = $${paramCount++}`);
      values.push(is_active);
    }
    if (is_featured !== undefined) {
      updates.push(`is_featured = $${paramCount++}`);
      values.push(is_featured);
    }
    if (expiry_type !== undefined) {
      updates.push(`expiry_type = $${paramCount++}`);
      values.push(expiry_type);
    }
    if (expiry_date !== undefined) {
      updates.push(`expiry_date = $${paramCount++}`);
      values.push(expiry_date || null);
    }
    if (expiry_days !== undefined) {
      updates.push(`expiry_days = $${paramCount++}`);
      values.push(expiry_days || null);
    }
    if (target_user_types !== undefined) {
      updates.push(`target_user_types = $${paramCount++}`);
      values.push(target_user_types);
    }
    if (max_redemptions_per_user !== undefined) {
      updates.push(`max_redemptions_per_user = $${paramCount++}`);
      values.push(max_redemptions_per_user || null);
    }
    if (max_redemptions_total !== undefined) {
      updates.push(`max_redemptions_total = $${paramCount++}`);
      values.push(max_redemptions_total || null);
    }
    if (valid_from !== undefined) {
      updates.push(`valid_from = $${paramCount++}`);
      values.push(valid_from || null);
    }
    if (valid_until !== undefined) {
      updates.push(`valid_until = $${paramCount++}`);
      values.push(valid_until || null);
    }
    if (image_url !== undefined) {
      updates.push(`image_url = $${paramCount++}`);
      values.push(image_url || null);
    }
    if (redemption_window !== undefined) {
      if (!['unlimited', 'once_per_day', 'once_per_week', 'once_per_month', 'once_per_shift'].includes(redemption_window)) {
        return res.status(400).json({ error: 'Invalid redemption_window' });
      }
      updates.push(`redemption_window = $${paramCount++}`);
      values.push(redemption_window);
    }
    if (requires_minimum_purchase !== undefined) {
      updates.push(`requires_minimum_purchase = $${paramCount++}`);
      values.push(requires_minimum_purchase || null);
    }
    if (valid_days_of_week !== undefined) {
      updates.push(`valid_days_of_week = $${paramCount++}`);
      values.push(valid_days_of_week || null);
    }
    if (valid_outlets !== undefined) {
      updates.push(`valid_outlets = $${paramCount++}`);
      values.push(valid_outlets || null);
    }
    if (auto_expire_hours !== undefined) {
      updates.push(`auto_expire_hours = $${paramCount++}`);
      values.push(auto_expire_hours || null);
    }

    if (updates.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    values.push(id);

    const result = await query(
      `UPDATE vouchers SET ${updates.join(', ')}, updated_at = CURRENT_TIMESTAMP WHERE id = $${paramCount} RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Voucher not found' });
    }

    const updatedVoucher = result.rows[0];

    // Audit log
    await logVoucherAction(req, 'update', updatedVoucher.id, updatedVoucher.title, {
      before: oldVoucher,
      after: updatedVoucher
    });

    res.json(updatedVoucher);
  } catch (error) {
    console.error('Update voucher error:', error);
    res.status(500).json({ error: 'Failed to update voucher' });
  }
});

// Redeem voucher - creates voucher instance with QR code
router.post('/:id/redeem', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params;
    const { user_id, payment_method = 'points', outlet_id, use_group_credits = false } = req.body;

    // Customers can only redeem for themselves
    if (req.user?.type === 'customer' && req.user.id !== parseInt(user_id)) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Get voucher details
    const voucherResult = await query('SELECT * FROM vouchers WHERE id = $1', [id]);
    if (voucherResult.rows.length === 0) {
      return res.status(404).json({ error: 'Voucher not found' });
    }
    const voucher = voucherResult.rows[0];

    // Check if voucher is active
    if (!voucher.is_active) {
      return res.status(400).json({ error: 'Voucher is not active' });
    }

    // Get user details
    const userResult = await query('SELECT * FROM users WHERE id = $1', [user_id]);
    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    const user = userResult.rows[0];

    // Check if user type is allowed to redeem this voucher
    const allowedTypes = voucher.target_user_types || voucher.allowed_user_types || ['customer', 'employee'];
    if (!allowedTypes.includes(user.user_type || 'customer')) {
      return res.status(403).json({
        error: 'This voucher is not available for your user type',
        allowed_types: allowedTypes
      });
    }

    // Check redemption window (frequency limit)
    if (voucher.redemption_window && voucher.redemption_window !== 'unlimited') {
      const windowCheckResult = await query(
        'SELECT check_redemption_window($1, $2) as allowed',
        [user_id, id]
      );
      if (!windowCheckResult.rows[0].allowed) {
        const windowMessages: Record<string, string> = {
          'once_per_day': 'You have already redeemed this voucher today',
          'once_per_week': 'You have already redeemed this voucher this week',
          'once_per_month': 'You have already redeemed this voucher this month',
          'once_per_shift': 'You have already redeemed this voucher this shift',
          'once_ever': 'You have already redeemed this voucher'
        };
        return res.status(400).json({
          error: windowMessages[voucher.redemption_window] || 'Redemption window limit reached',
          redemption_window: voucher.redemption_window
        });
      }
    }

    // Check day of week restrictions
    if (voucher.valid_days_of_week && voucher.valid_days_of_week.length > 0) {
      const dayCheckResult = await query(
        'SELECT check_voucher_day_of_week($1) as allowed',
        [id]
      );
      if (!dayCheckResult.rows[0].allowed) {
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const today = dayNames[new Date().getDay()];
        return res.status(400).json({
          error: `This voucher is not valid on ${today}`,
          valid_days: voucher.valid_days_of_week
        });
      }
    }

    // Check minimum purchase requirement
    const { purchase_amount } = req.body;
    if (voucher.requires_minimum_purchase && voucher.requires_minimum_purchase > 0) {
      if (!purchase_amount || purchase_amount < voucher.requires_minimum_purchase) {
        return res.status(400).json({
          error: `Minimum purchase of ${voucher.requires_minimum_purchase} THB required`,
          minimum_purchase: voucher.requires_minimum_purchase,
          current_purchase: purchase_amount || 0
        });
      }
    }

    // Check company exclusivity
    if (voucher.is_company_exclusive && voucher.allowed_company_ids && voucher.allowed_company_ids.length > 0) {
      if (!user.company_id || !voucher.allowed_company_ids.includes(user.company_id)) {
        return res.status(403).json({
          error: 'This voucher is only available for specific company employees'
        });
      }
    }

    // Check outlet restrictions
    if (voucher.valid_outlets && voucher.valid_outlets.length > 0 && outlet_id) {
      if (!voucher.valid_outlets.includes(outlet_id.toString())) {
        return res.status(400).json({
          error: 'This voucher is not valid at this outlet',
          valid_outlets: voucher.valid_outlets
        });
      }
    }

    // Check max redemptions per user
    if (voucher.max_redemptions_per_user) {
      const userRedemptionsResult = await query(
        `SELECT COUNT(*) as redemption_count FROM voucher_instances
         WHERE voucher_id = $1 AND user_id = $2 AND status IN ('active', 'used')`,
        [id, user_id]
      );
      const userRedemptionCount = parseInt(userRedemptionsResult.rows[0].redemption_count);

      if (userRedemptionCount >= voucher.max_redemptions_per_user) {
        return res.status(400).json({
          error: `You have reached the maximum redemption limit for this voucher (${voucher.max_redemptions_per_user} times)`,
          limit: voucher.max_redemptions_per_user,
          current: userRedemptionCount
        });
      }
    }

    // Check max total redemptions
    if (voucher.max_redemptions_total) {
      const totalRedemptionsResult = await query(
        `SELECT COUNT(*) as redemption_count FROM voucher_instances
         WHERE voucher_id = $1 AND status IN ('active', 'used')`,
        [id]
      );
      const totalRedemptionCount = parseInt(totalRedemptionsResult.rows[0].redemption_count);

      if (totalRedemptionCount >= voucher.max_redemptions_total) {
        return res.status(400).json({
          error: 'This voucher has reached its total redemption limit',
          limit: voucher.max_redemptions_total
        });
      }
    }

    // Check valid date range
    const now = new Date();
    if (voucher.valid_from && new Date(voucher.valid_from) > now) {
      return res.status(400).json({
        error: 'This voucher is not yet valid',
        valid_from: voucher.valid_from
      });
    }
    if (voucher.valid_until && new Date(voucher.valid_until) < now) {
      return res.status(400).json({
        error: 'This voucher has expired',
        valid_until: voucher.valid_until
      });
    }

    // Check expiry date
    if (voucher.expiry_date && new Date(voucher.expiry_date) < now) {
      return res.status(400).json({
        error: 'This voucher has expired',
        expiry_date: voucher.expiry_date
      });
    }

    // Determine cost and check balance based on payment method
    let cost: number;
    let currency: string;

    if (user.user_type === 'investor' && payment_method === 'investor_credits') {
      // Calculate investor cost with discount
      cost = voucher.investor_credits_cost || Math.ceil(voucher.points_required * (100 - (user.investor_discount_percentage || 25)) / 100);
      currency = 'investor_credits';

      // Check if using outlet or group credits
      if (use_group_credits) {
        if (!user.investor_group_credits_enabled) {
          return res.status(400).json({ error: 'Group credits not enabled for this user' });
        }
        // Check group credits expiry
        if (user.investor_group_credits_expires_at && new Date(user.investor_group_credits_expires_at) < new Date()) {
          return res.status(400).json({ error: 'Your group credits have expired' });
        }
        if (user.investor_group_credits_balance < cost) {
          return res.status(400).json({
            error: 'Insufficient group credits',
            required: cost,
            current: user.investor_group_credits_balance
          });
        }
      } else {
        if (!outlet_id) {
          return res.status(400).json({ error: 'outlet_id required for outlet credits redemption' });
        }
        // Check outlet credits with expiry validation
        const outletCreditResult = await query(
          `SELECT credits_balance, expires_at FROM investor_outlet_credits
           WHERE user_id = $1 AND outlet_id = $2`,
          [user_id, outlet_id]
        );
        if (outletCreditResult.rows.length === 0) {
          return res.status(400).json({
            error: 'No outlet credits allocated for this outlet',
            required: cost,
            current: 0
          });
        }
        const outletCredit = outletCreditResult.rows[0];
        // Check expiry
        if (outletCredit.expires_at && new Date(outletCredit.expires_at) < new Date()) {
          return res.status(400).json({ error: 'Your outlet credits have expired' });
        }
        if (outletCredit.credits_balance < cost) {
          return res.status(400).json({
            error: 'Insufficient outlet credits',
            required: cost,
            current: outletCredit.credits_balance
          });
        }
      }
    } else if (user.user_type === 'media' && payment_method === 'media_budget') {
      // Media budget redemption
      cost = voucher.media_budget_cost_thb || voucher.cash_value;
      currency = 'media_budget_thb';

      // Check media budget expiry
      if (user.media_budget_expires_at && new Date(user.media_budget_expires_at) < new Date()) {
        return res.status(400).json({ error: 'Your media budget has expired' });
      }

      const remaining = (user.media_annual_budget_thb || 0) - (user.media_spent_this_year_thb || 0);
      if (remaining < cost) {
        return res.status(400).json({
          error: 'Insufficient media budget',
          required: cost,
          remaining: remaining
        });
      }
    } else {
      // Regular points redemption
      cost = voucher.points_required;
      currency = 'points';

      if (user.points_balance < cost) {
        return res.status(400).json({
          error: 'Insufficient points',
          required: cost,
          current: user.points_balance
        });
      }
    }

    // Calculate expiry based on voucher expiry_type
    let expiresAt: Date;
    if (voucher.expiry_type === 'days_after_redeem' && voucher.expiry_days) {
      expiresAt = new Date(Date.now() + voucher.expiry_days * 24 * 60 * 60 * 1000);
    } else if (voucher.expiry_type === 'fixed_date' && voucher.expiry_date) {
      expiresAt = new Date(voucher.expiry_date);
    } else {
      // Default: 10 minutes for QR code
      expiresAt = new Date(Date.now() + 10 * 60 * 1000);
    }

    // Generate UUID and QR token
    const uuid = uuidv4();
    const customerId = user.id.toString().padStart(6, '0');

    const qrData = {
      type: 'voucher_redemption',
      customer_id: customerId,
      voucher_id: id.toString(),
      voucher_instance_id: uuid,
      expires_at: expiresAt.toISOString()
    };

    const qrToken = generateQRToken(qrData, '10m');

    // Create voucher instance
    const instanceResult = await query(
      `INSERT INTO voucher_instances
       (uuid, user_id, voucher_id, qr_code_data, status, redeemed_at, expires_at)
       VALUES ($1, $2, $3, $4, $5, NOW(), $6)
       RETURNING *`,
      [uuid, user_id, id, qrToken, 'active', expiresAt]
    );

    // Deduct cost based on currency type
    if (currency === 'investor_credits') {
      if (use_group_credits) {
        // Deduct from group credits
        const newBalance = user.investor_group_credits_balance - cost;
        await query(
          'UPDATE users SET investor_group_credits_balance = $1 WHERE id = $2',
          [newBalance, user_id]
        );

        // Log credit transaction
        await query(
          `INSERT INTO credit_transactions
           (user_id, credit_type, transaction_type, credits_change, balance_after, voucher_id, outlet_id)
           VALUES ($1, $2, $3, $4, $5, $6, $7)`,
          [user_id, 'investor_group', 'redemption', -cost, newBalance, id, null]
        );
      } else {
        // Deduct from outlet credits
        const outletCreditResult = await query(
          `UPDATE investor_outlet_credits
           SET credits_balance = credits_balance - $1, updated_at = NOW()
           WHERE user_id = $2 AND outlet_id = $3
           RETURNING credits_balance`,
          [cost, user_id, outlet_id]
        );
        const newBalance = outletCreditResult.rows[0].credits_balance;

        // Log credit transaction
        await query(
          `INSERT INTO credit_transactions
           (user_id, credit_type, outlet_id, transaction_type, credits_change, balance_after, voucher_id)
           VALUES ($1, $2, $3, $4, $5, $6, $7)`,
          [user_id, 'investor_outlet', outlet_id, 'redemption', -cost, newBalance, id]
        );
      }
    } else if (currency === 'media_budget_thb') {
      // Deduct from media budget
      const newSpent = parseFloat(user.media_spent_this_year_thb) + cost;
      await query(
        'UPDATE users SET media_spent_this_year_thb = $1 WHERE id = $2',
        [newSpent, user_id]
      );

      // Log credit transaction
      await query(
        `INSERT INTO credit_transactions
         (user_id, credit_type, transaction_type, amount_thb, voucher_id, outlet_id)
         VALUES ($1, $2, $3, $4, $5, $6)`,
        [user_id, 'media', 'redemption', cost, id, outlet_id]
      );
    } else {
      // Deduct regular points
      const newBalance = user.points_balance - cost;
      await query(
        'UPDATE users SET points_balance = $1 WHERE id = $2',
        [newBalance, user_id]
      );

      // Create transaction record
      await query(
        `INSERT INTO transactions
         (user_id, type, points_delta, amount_value, voucher_id)
         VALUES ($1, $2, $3, $4, $5)`,
        [user_id, 'redeem', -cost, voucher.cash_value, id]
      );
    }

    res.json({
      voucher_instance: {
        ...instanceResult.rows[0],
        voucher: voucher
      }
    });
  } catch (error) {
    console.error('Redeem voucher error:', error);
    res.status(500).json({ error: 'Failed to redeem voucher' });
  }
});

// Get user's voucher instances
router.get('/instances/:user_id', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const { user_id } = req.params;
    const { status } = req.query;

    // Customers can only view their own instances
    if (req.user?.type === 'customer' && req.user.id !== parseInt(user_id)) {
      return res.status(403).json({ error: 'Access denied' });
    }

    let sql = `
      SELECT vi.*, v.title, v.description, v.image_url, v.cash_value, v.voucher_type
      FROM voucher_instances vi
      JOIN vouchers v ON vi.voucher_id = v.id
      WHERE vi.user_id = $1
    `;
    const params: any[] = [user_id];

    if (status) {
      sql += ` AND vi.status = $2`;
      params.push(status);
    }

    sql += ` ORDER BY vi.redeemed_at DESC`;

    const result = await query(sql, params);

    res.json({ voucher_instances: result.rows });
  } catch (error) {
    console.error('Get voucher instances error:', error);
    res.status(500).json({ error: 'Failed to fetch voucher instances' });
  }
});

// Delete voucher (hard delete - admin only)
router.delete('/:id', authenticate, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params;

    // Get voucher details before deleting for audit trail
    const voucherResult = await query('SELECT * FROM vouchers WHERE id = $1', [id]);
    if (voucherResult.rows.length === 0) {
      return res.status(404).json({ error: 'Voucher not found' });
    }
    const deletedVoucher = voucherResult.rows[0];

    const result = await query(
      'DELETE FROM vouchers WHERE id = $1 RETURNING id',
      [id]
    );

    // Audit log
    await logVoucherAction(req, 'delete', deletedVoucher.id, deletedVoucher.title, {
      before: deletedVoucher
    });

    res.json({ message: 'Voucher deleted successfully', id: result.rows[0].id });
  } catch (error) {
    console.error('Delete voucher error:', error);
    res.status(500).json({ error: 'Failed to delete voucher' });
  }
});

export default router;
